#version 450 core
#extension GL_KHR_shader_subgroup_arithmetic : require
#extension GL_EXT_control_flow_attributes : enable

// block_size = [subGroupSize, H, C]
layout (local_size_x_id = 253, local_size_y_id = 254,
        local_size_z_id = 255) in;

layout (constant_id = 0) const float power = 2.0;
layout (constant_id = 1) const float eps = .0;

layout (push_constant) uniform constants
{
  uint C;
  uint H;
  uint W;
};

layout (set = 0, binding = 0) readonly buffer InTensor0
{
  float input_tensor[];
};

layout (set = 0, binding = 1) readonly buffer InTensor1
{
  float input_weights[];
};

layout (set = 0, binding = 2) writeonly buffer OutTensor
{
  float output_tensor[];
};

void
main (void)
{
  uint c = gl_GlobalInvocationID.z;
  uint h = gl_GlobalInvocationID.y;

  if (c >= C || h >= H)
    return;

  float r = .0;
  [[unroll]] for (uint w = gl_SubgroupInvocationID.x; w < W;
                  w += gl_SubgroupSize)
    {
      float v = (input_tensor[c * H * W + h * W + w]);
      v = pow (v, power);
      r += v;
    }

  float alpha = 1.0 / (sqrt (subgroupAdd (r) / (W) + eps));

  [[unroll]] for (uint ow = gl_SubgroupInvocationID.x; ow < W;
                  ow += gl_SubgroupSize)
    {
      float v = (input_tensor[c * H * W + h * W + ow]);
      float w = (input_weights[ow]);
      output_tensor[c * H * W + h * W + ow] = float16_t (v * w * alpha);
    }
}

