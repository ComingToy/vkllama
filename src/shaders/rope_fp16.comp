#version 450 core
#extension GL_EXT_shader_16bit_storage : require

layout (local_size_x_id = 253, local_size_y_id = 254,
        local_size_z_id = 255) in;

layout (binding = 0) readonly buffer InputTensor0 { float16_t input_query[]; };

layout (binding = 1) readonly buffer InputTensor2 { float16_t rope_freqc[]; };
layout (binding = 2) readonly buffer InputTensor3 { float16_t rope_freqs[]; };

layout (binding = 3) writeonly buffer OutputTensor0 { float16_t output_kq[]; };

layout (push_constant) uniform constants
{
  uint C;      // batch size
  uint H;      // seqlen
  uint W;      // token dim
  uint offset; // kvcache offset
};

void
main (void)
{
  uint tid_x = gl_GlobalInvocationID.x;
  uint tid_y = gl_GlobalInvocationID.y;
  uint tid_z = gl_GlobalInvocationID.z;

  if (tid_z >= C || tid_y >= H || 2*tid_x >= W)
    {
      return;
    }

  float freqc = float (rope_freqc[(tid_y + offset) * W / 2 + tid_x]);
  float freqs = float (rope_freqs[(tid_y + offset) * W / 2 + tid_x]);

  uint src_idx = tid_z * H * W + tid_y * W + 2 * tid_x;
  float q0 = float (input_query[src_idx]);
  float q1 = float (input_query[src_idx + 1]);

  float qr0 = q0 * freqc - q1 * freqs;
  float qr1 = q0 * freqs + q1 * freqc;

  output_kq[src_idx] = float16_t (qr0);
  output_kq[src_idx + 1] = float16_t (qr1);
}
