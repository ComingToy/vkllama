#version 450 core
layout (local_size_x_id = 253, local_size_y_id = 254,
        local_size_z_id = 255) in;

layout (push_constant) uniform constants
{
  uint C;
  uint H;
  uint W;
};

// shape of input0 [C, H, W], shape of input1 [C, H, 1]
layout (binding = 0) readonly buffer InputTensor0 { float input0[]; };
layout (binding = 1) readonly buffer InputTensor1 { float input1[]; };

// shape of output0 [C, H, Gx]
layout (binding = 2) writeonly buffer OutputTensor0 { float output0[]; };
// shape of output1 [C, H, W]
layout (binding = 3) writeonly buffer OutputTensor1 { float output1[]; };

// block size [32, 4, 1]
shared float smem[4][32];

void
main (void)
{
  uint glb_tid_x = gl_GlobalInvocationID.x;
  uint glb_tid_y = gl_GlobalInvocationID.y;
  uint glb_tid_z = gl_GlobalInvocationID.z;
  uint loc_tid_x = gl_LocalInvocationID.x;
  uint loc_tid_y = gl_LocalInvocationID.y;
  uint loc_tid_z = gl_LocalInvocationID.z;

  uint G = gl_NumWorkGroups.x;
  uint group_x = gl_WorkGroupSize.x;
  uint group_id = gl_WorkGroupID.x;

  smem[loc_tid_y][loc_tid_x] = .0;
  if (glb_tid_x >= W || glb_tid_y >= H || glb_tid_z >= C)
    {
      return;
    }

  const float bias = input1[glb_tid_z * C + glb_tid_y];
  const uint idx = glb_tid_z * H * W + glb_tid_y * W + glb_tid_x;

  const float e = exp (input0[idx] - bias);
  smem[loc_tid_y][loc_tid_x] = e;
  output1[idx] = e;
  barrier ();

  for (uint stride = group_x / 2; stride > 0; stride /= 2)
    {
      if (loc_tid_x < stride)
        {
          smem[loc_tid_y][loc_tid_x] += smem[loc_tid_y][loc_tid_x + stride];
        }
      barrier ();
    }

  if (loc_tid_x == 0)
    output0[glb_tid_z * H * G + glb_tid_y * G + group_id] = smem[loc_tid_y][0];
}
