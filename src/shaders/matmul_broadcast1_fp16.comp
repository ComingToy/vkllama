#version 450 core
#extension GL_EXT_shader_16bit_storage : require

layout (local_size_x_id = 253, local_size_y_id = 254,
        local_size_z_id = 255) in;

layout (constant_id = 0) const int act = 0;
layout (constant_id = 1) const int transpose_b = 0;
layout (set = 0, binding = 0) readonly buffer V1 { float16_t values[]; }
v1;
layout (set = 0, binding = 1) readonly buffer V2 { float16_t values[]; }
v2;
layout (set = 0, binding = 2) writeonly buffer V3 { float16_t values[]; }
v3;

layout (push_constant) uniform constants
{
  int C;
  int M;
  int N;
  int K;
}
pushed_constants;

// block size = [16, 16] = 256
shared float tileA[32][8];
shared float tileB[8][32];

void
main (void)
{
  int C = pushed_constants.C;
  int M = pushed_constants.M;
  int N = pushed_constants.N;
  int K = pushed_constants.K;

  uint x = gl_GlobalInvocationID.x;
  uint y = gl_GlobalInvocationID.y;
  uint z = gl_GlobalInvocationID.z;
  if (z >= C)
    return;

  uint tid_y = gl_LocalInvocationID.y;
  uint tid_x = gl_LocalInvocationID.x;

  uint tid = tid_y * 16 + tid_x;
  uint by = gl_WorkGroupID.y;
  uint bx = gl_WorkGroupID.x;

  // reshape a block to [32, 8]
  uint tid_a_y = tid / 8;
  uint tid_a_x = tid % 8;
  // reshape b block to [8, 32]
  uint tid_b_y = tid / 32;
  uint tid_b_x = tid % 32;

  uint a_y = (by * 32 + tid_a_y);
  uint b_x = bx * 32 + tid_b_x;

  float results[2][2] = {
    {
        .0,
        .0,
    },
    {
        .0,
        .0,
    },
  };

  uint a_channel_base = z * M * K;

  for (int i = 0; i < (K + 7) / 8; ++i)
    {
      if (a_y < M && i * 8 + tid_a_x < K)
        {
          uint a_src_idx = a_channel_base + a_y * K + i * 8 + tid_a_x;
          tileA[tid_a_y][tid_a_x] = float (v1.values[a_src_idx]);
        }
      else
        {
          tileA[tid_a_y][tid_a_x] = .0;
        }

      if (b_x < N && i * 8 + tid_b_y < K)
        {
          uint b_src_idx = 0;
          if (transpose_b > 0)
            {
              b_src_idx = b_x * K + i * 8 + tid_b_y;
            }
          else
            {
              b_src_idx = (i * 8 + tid_b_y) * N + b_x;
            }
          tileB[tid_b_y][tid_b_x] = float (v2.values[b_src_idx]);
        }
      else
        {
          tileB[tid_b_y][tid_b_x] = .0;
        }

      barrier ();

      for (int k = 0; k < 8; ++k)
        {
          results[0][0] += tileA[tid_y * 2 + 0][k] * tileB[k][tid_x * 2 + 0];
          results[0][1] += tileA[tid_y * 2 + 0][k] * tileB[k][tid_x * 2 + 1];
          results[1][0] += tileA[tid_y * 2 + 1][k] * tileB[k][tid_x * 2 + 0];
          results[1][1] += tileA[tid_y * 2 + 1][k] * tileB[k][tid_x * 2 + 1];
        }

      barrier ();
    }

  uint m = by * 32 + tid_y * 2;
  uint n = bx * 32 + tid_x * 2;
  uint c_channel_base = z * M * N;

  if (m < M && n < N)
    {
      float x = results[0][0];
      v3.values[c_channel_base + m * N + n]
          = float16_t (act == 1 ? x / (1 + exp (-x)) : x);
    }

  if (m + 1 < M && n < N)
    {
      float x = results[1][0];
      v3.values[c_channel_base + (m + 1) * N + n]
          = float16_t (act == 1 ? x / (1 + exp (-x)) : x);
    }

  if (n + 1 < N && m < M)
    {
      float x = results[0][1];
      v3.values[c_channel_base + m * N + n + 1]
          = float16_t (act == 1 ? x / (1 + exp (-x)) : x);
    }

  if (m + 1 < M && n + 1 < N)
    {
      float x = results[1][1];
      v3.values[c_channel_base + (m + 1) * N + n + 1]
          = float16_t (act == 1 ? x / (1 + exp (-x)) : x);
    }
}
