#version 450 core
#extension GL_EXT_shader_16bit_storage : require
#extension GL_EXT_shader_explicit_arithmetic_types_float16 : require
layout (local_size_x_id = 253, local_size_y_id = 254,
        local_size_z_id = 255) in;

layout (constant_id = 0) const float16_t power = 2.0hf;
layout (push_constant) uniform constants
{
  uint C;
  uint H;
  uint W;
};

layout (binding = 0) readonly buffer InputTensor0 { float16_t input0[]; };

layout (binding = 1) readonly buffer InputTensor1 { float16_t input1[]; };

layout (binding = 2) writeonly buffer OutTensor0 { float16_t output0[]; };

layout (binding = 3) writeonly buffer OutTensor1 { float16_t output1[]; };

// block_x = 64, block_y = 4, block_z = 1
shared float16_t smem[4][64];

void
main (void)
{
  uint glb_tid_x = gl_GlobalInvocationID.x;
  uint glb_tid_y = gl_GlobalInvocationID.y;
  uint glb_tid_z = gl_GlobalInvocationID.z;

  uint loc_tid_x = gl_LocalInvocationID.x;
  uint loc_tid_y = gl_LocalInvocationID.y;

  uint group_x = gl_WorkGroupSize.x;
  uint group_id = gl_WorkGroupID.x;
  uint WO = gl_NumWorkGroups.x;

  if (glb_tid_y >= H || glb_tid_z >= C)
    {
      return;
    }

  const uint in_base = glb_tid_z * H * W + glb_tid_y * W;
  const uint out_base = glb_tid_z * H * WO + glb_tid_y * WO;

  float16_t v = .0hf;
  if (glb_tid_x < W)
    {
      v = input0[in_base + glb_tid_x];
      output1[in_base + glb_tid_x] = v * input1[glb_tid_x];
      smem[loc_tid_y][loc_tid_x] = pow (v, power);
    }
  else
    {
      smem[loc_tid_y][loc_tid_x] = .0hf;
    }

  barrier ();

  for (uint stride = group_x / 2; stride > 0; stride /= 2)
    {
      if (loc_tid_x < stride)
        {
          smem[loc_tid_y][loc_tid_x] += smem[loc_tid_y][loc_tid_x + stride];
        }
      barrier ();
    }

  if (loc_tid_x == 0)
    {
      output0[out_base + group_id] = smem[loc_tid_y][0];
    }
}
