#version 450 core
layout (local_size_x_id = 253, local_size_y_id = 254, local_size_z_id = 255) in;

layout(constant_id=0) const int act = 0;
layout(set=0, binding=0) readonly buffer V1 {float values[];} v1;
layout(set=0, binding=1) readonly buffer V2 {float values[];} v2;
layout(set=0, binding=2) writeonly buffer V3 {float values[];} v3;

layout(push_constant) uniform constants
{
    int C;
	int M;
	int N;
    int K;
} pushed_constants;

// block size = [16, 16] = 256
shared float tileA[4][32][8];
shared float tileB[4][8][32];

void main(void)
{
    int C = pushed_constants.C;
    int M = pushed_constants.M;
    int N = pushed_constants.N;
    int K = pushed_constants.K;

    uint x = gl_GlobalInvocationID.x;
    uint y = gl_GlobalInvocationID.y;
    uint z = gl_GlobalInvocationID.z;

    if (z >= C){
        return;
    }

    uint tid_y = gl_LocalInvocationID.y;
    uint tid_x = gl_LocalInvocationID.x;
    uint tid_z = gl_LocalInvocationID.z;

    uint tid = tid_y * 16 + tid_x;
    uint by = gl_WorkGroupID.y;
    uint bx = gl_WorkGroupID.x;

    // reshape a block to [32, 8]
    uint tid_a_y = tid / 8;
    uint tid_a_x = tid % 8;
    // reshape b block to [8, 32]
    uint tid_b_y = tid/32;
    uint tid_b_x = tid % 32;

    uint a_y = (by*32+ tid_a_y);
    uint b_x = bx*32+ tid_b_x;

    float results[2][2] = {
        {.0, .0,}, 
        {.0, .0,}, 
    };

    uint a_channel_base = z * M * K;
    uint b_channel_base = z * K * N;
    
    for (int i = 0; i < (K + 7)/8; ++i)
    {
        if (a_y < M && i*8 + tid_a_x < K){
            uint a_src_idx = a_channel_base + a_y*K + i*8 + tid_a_x;
            tileA[tid_z][tid_a_y][tid_a_x] = v1.values[a_src_idx];
        }else{
            tileA[tid_z][tid_a_y][tid_a_x] = .0;
        }

        if (b_x < N && i*8 + tid_b_y < K){
            uint b_src_idx = b_channel_base + (i*8 + tid_b_y)*N + b_x;
            tileB[tid_z][tid_b_y][tid_b_x] = v2.values[b_src_idx];
        }else{
            tileB[tid_z][tid_b_y][tid_b_x] = .0;
        }

        barrier();
        
        for (int k = 0; k < 8; ++k)
        {
            results[0][0] += tileA[tid_z][tid_y*2 + 0][k] * tileB[tid_z][k][tid_x*2 + 0];
            results[0][1] += tileA[tid_z][tid_y*2 + 0][k] * tileB[tid_z][k][tid_x*2 + 1];
            results[1][0] += tileA[tid_z][tid_y*2 + 1][k] * tileB[tid_z][k][tid_x*2 + 0];
            results[1][1] += tileA[tid_z][tid_y*2 + 1][k] * tileB[tid_z][k][tid_x*2 + 1];
        }

        barrier();
    }

    uint m = by * 32 + tid_y * 2;
    uint n = bx * 32 + tid_x * 2;
    uint c_channel_base = z * M * N;
    
    if (m < M && n < N){
		float x = results[0][0];
        v3.values[c_channel_base + m*N + n] = act == 1 ? x / (1 + exp(-x)) : x;
    }

    if (m + 1 < M && n < N){
		float x = results[1][0];
        v3.values[c_channel_base + (m+1)*N + n] = act == 1 ? x/(1 + exp(-x)) : x;
    }

    if (n + 1 < N && m < M)
    {
		float x = results[0][1];
        v3.values[c_channel_base + m*N + n + 1] = act == 1 ? x/(1 + exp(-x)) : x;
    }

    if (m + 1 < M && n + 1 < N){
		float x = results[1][1];
        v3.values[c_channel_base + (m+1)*N + n + 1] = act == 1 ? x/(1 + exp(-x)) : x;
    }
}
